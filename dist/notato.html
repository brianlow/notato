<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>notato - Image Annotation Tool</title>
    <style>
/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary-color: #2563eb;
    --primary-hover: #1d4ed8;
    --secondary-color: #64748b;
    --success-color: #10b981;
    --danger-color: #ef4444;
    --warning-color: #f59e0b;
    --background: #f8fafc;
    --surface: #ffffff;
    --border-color: #e2e8f0;
    --text-primary: #1e293b;
    --text-secondary: #64748b;
    --sidebar-width: 320px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    color: var(--text-primary);
    background: var(--background);
    overflow: hidden;
}

/* Layout */
.app-container {
    display: flex;
    height: 100vh;
    width: 100vw;
}

.sidebar {
    width: var(--sidebar-width);
    background: var(--surface);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Sidebar Sections */
.format-section,
.class-section,
.file-section {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
}

.format-section h2 {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 12px;
    color: var(--primary-color);
}

.format-section h3,
.class-section h3,
.file-section h3 {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

/* Load Buttons */
.load-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.load-buttons .btn-primary {
    flex: 1;
}

.folder-path {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 8px;
    word-break: break-all;
}

/* Buttons */
.btn-primary,
.btn-secondary,
.btn-icon,
.btn-small {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-primary {
    background: var(--primary-color);
    color: white;
    width: 100%;
}

.btn-primary:hover {
    background: var(--primary-hover);
}

.btn-primary:disabled {
    background: var(--secondary-color);
    cursor: not-allowed;
    opacity: 0.5;
}

.btn-primary.unsaved {
    background: var(--warning-color);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
}

.btn-secondary {
    background: var(--surface);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}

.btn-secondary:hover {
    background: var(--background);
}

.btn-icon {
    padding: 6px 10px;
    background: var(--surface);
    border: 1px solid var(--border-color);
    font-size: 16px;
}

.btn-icon:hover {
    background: var(--background);
    border-color: var(--primary-color);
}

.btn-small {
    padding: 4px 10px;
    background: var(--primary-color);
    color: white;
    font-size: 18px;
    line-height: 1;
}

.btn-small:hover {
    background: var(--primary-hover);
}

/* Class Section */
.class-selector-wrapper {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.class-selector {
    flex: 1;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 14px;
    background: var(--surface);
}

.class-list {
    display: flex;
    flex-direction: column;
    gap: 4px;
    max-height: 150px;
    overflow-y: auto;
}

.class-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
}

.class-item:hover {
    background: var(--background);
}

.class-item.active {
    background: #eff6ff;
    border: 1px solid var(--primary-color);
}

.class-color {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.class-name {
    flex: 1;
    font-size: 13px;
}

.class-count {
    font-size: 11px;
    color: var(--text-secondary);
    background: var(--background);
    padding: 2px 6px;
    border-radius: 10px;
}

/* File Section */
.file-section {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.search-input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 13px;
    margin-bottom: 12px;
}

.search-input:focus {
    outline: none;
    border-color: var(--primary-color);
}

.file-list {
    flex: 1;
    overflow-y: auto;
}

.file-list::-webkit-scrollbar {
    width: 8px;
}

.file-list::-webkit-scrollbar-track {
    background: var(--background);
}

.file-list::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 4px;
}

.file-list::-webkit-scrollbar-thumb:hover {
    background: var(--secondary-color);
}

.file-group {
    margin-bottom: 16px;
}

.file-group-header {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    padding: 6px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
}

.file-group-header:hover {
    color: var(--text-primary);
}

.file-group-toggle {
    font-size: 10px;
}

.file-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
    margin-bottom: 4px;
}

.file-item:hover {
    background: var(--background);
}

.file-item.active {
    background: #eff6ff;
    border: 1px solid var(--primary-color);
}

.file-thumbnail {
    width: 50px;
    height: 50px;
    border-radius: 4px;
    object-fit: cover;
    border: 1px solid var(--border-color);
}

.file-info {
    flex: 1;
    min-width: 0;
}

.file-name {
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.file-meta {
    font-size: 11px;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 6px;
    margin-top: 2px;
}

.file-status {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.file-status.annotated {
    background: var(--success-color);
}

.file-status.unannotated {
    background: var(--border-color);
}

.file-status.modified {
    background: var(--warning-color);
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-secondary);
}

.empty-state p {
    margin-bottom: 8px;
}

.empty-state .hint {
    font-size: 12px;
    color: var(--text-secondary);
}

/* Toolbar */
.toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border-color);
}

.toolbar-left,
.toolbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
}

.file-info {
    font-weight: 500;
}

.annotation-count {
    font-size: 12px;
    color: var(--text-secondary);
    background: var(--background);
    padding: 4px 8px;
    border-radius: 12px;
}

.zoom-level {
    font-size: 13px;
    font-weight: 500;
    min-width: 45px;
    text-align: center;
}

/* Canvas */
.canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #f1f5f9;
    display: flex;
    align-items: center;
    justify-content: center;
}

#mainCanvas {
    display: block;
    cursor: crosshair;
    background: white;
}

#mainCanvas.panning {
    cursor: grab;
}

#mainCanvas.panning:active {
    cursor: grabbing;
}

.empty-canvas-state {
    position: absolute;
    text-align: center;
    color: var(--text-secondary);
}

.empty-canvas-state h2 {
    font-size: 24px;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.empty-canvas-state p {
    margin-bottom: 4px;
}

.empty-canvas-state .hint {
    font-size: 12px;
}

/* Status Bar */
.status-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 16px;
    background: var(--surface);
    border-top: 1px solid var(--border-color);
    font-size: 12px;
    color: var(--text-secondary);
}

.cursor-pos {
    font-family: 'Courier New', monospace;
}

.shortcut-hint {
    font-style: italic;
}

/* Modals */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal.active {
    display: flex;
}

.modal-content {
    background: var(--surface);
    padding: 24px;
    border-radius: 8px;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
    max-width: 500px;
    width: 90%;
}

.modal-content h3 {
    font-size: 18px;
    margin-bottom: 16px;
    color: var(--text-primary);
}

.modal-input {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 16px;
}

.modal-input:focus {
    outline: none;
    border-color: var(--primary-color);
}

.modal-buttons {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}

.modal-buttons .btn-primary,
.modal-buttons .btn-secondary {
    width: auto;
}

/* Shortcuts Modal */
.shortcuts-list {
    display: grid;
    gap: 12px;
    margin-bottom: 20px;
    max-height: 400px;
    overflow-y: auto;
}

.shortcut-item {
    display: flex;
    align-items: center;
    gap: 16px;
}

.shortcut-item kbd {
    background: var(--background);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 8px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    min-width: 80px;
    text-align: center;
}

.shortcut-item span {
    color: var(--text-secondary);
}

/* Toast Notifications */
.toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.toast {
    background: var(--surface);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 12px 16px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    min-width: 250px;
    display: flex;
    align-items: center;
    gap: 12px;
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.toast.success {
    border-left: 4px solid var(--success-color);
}

.toast.error {
    border-left: 4px solid var(--danger-color);
}

.toast.warning {
    border-left: 4px solid var(--warning-color);
}

.toast.info {
    border-left: 4px solid var(--primary-color);
}

.toast-icon {
    font-size: 20px;
}

.toast-message {
    flex: 1;
    font-size: 14px;
}

/* Utility Classes */
.hidden {
    display: none !important;
}

.loading {
    opacity: 0.6;
    pointer-events: none;
}

/* Crosshair Cursor */
.crosshair-cursor {
    cursor: none;
}

/* Print styles */
@media print {
    .sidebar,
    .toolbar,
    .status-bar {
        display: none;
    }

    .main-content {
        width: 100%;
    }
}

</style>
</head>
<body>
    <div class="app-container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <!-- Format Selection -->
            <div class="format-section">
                <h2>notato</h2>
                <div class="load-buttons">
                    <button id="loadYoloBtn" class="btn-primary">Load YOLO</button>
                    <button id="loadCocoBtn" class="btn-primary">Load COCO</button>
                </div>
                <div id="folderPath" class="folder-path"></div>
            </div>

            <!-- Class Management -->
            <div class="class-section">
                <h3>Classes</h3>
                <div class="class-selector-wrapper">
                    <select id="classSelector" class="class-selector">
                        <option value="0">Class 0</option>
                    </select>
                    <button id="addClassBtn" class="btn-small" title="Add Class">+</button>
                </div>
                <div id="classList" class="class-list"></div>
            </div>

            <!-- File List -->
            <div class="file-section">
                <h3>Images</h3>
                <input type="text" id="fileSearch" class="search-input" placeholder="Search files...">
                <div id="fileList" class="file-list">
                    <div class="empty-state">
                        <p>No folder loaded</p>
                        <p class="hint">Click "Open Folder" to get started</p>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Canvas Area -->
        <main class="main-content">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="toolbar-left">
                    <span id="fileInfo" class="file-info">No image loaded</span>
                    <span id="annotationCount" class="annotation-count"></span>
                </div>
                <div class="toolbar-right">
                    <button id="zoomOutBtn" class="btn-icon" title="Zoom Out (-)">‚àí</button>
                    <span id="zoomLevel" class="zoom-level">100%</span>
                    <button id="zoomInBtn" class="btn-icon" title="Zoom In (+)">+</button>
                    <button id="fitToScreenBtn" class="btn-icon" title="Fit to Screen (0)">‚ä°</button>
                    <button id="toggleBoxesBtn" class="btn-icon" title="Toggle Boxes (H)">üëÅ</button>
                    <button id="saveBtn" class="btn-primary" title="Save (Ctrl+S)">Save</button>
                </div>
            </div>

            <!-- Canvas Container -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="mainCanvas"></canvas>
                <div class="empty-canvas-state">
                    <h2>Welcome to notato</h2>
                    <p>Open a folder to start annotating images</p>
                    <p class="hint">Supports YOLO and COCO formats</p>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span id="cursorPos" class="cursor-pos"></span>
                <span id="statusMessage" class="status-message">Ready</span>
                <span id="shortcutHint" class="shortcut-hint">
                    Press ? for keyboard shortcuts
                </span>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="addClassModal" class="modal">
        <div class="modal-content">
            <h3>Add New Class</h3>
            <input type="text" id="newClassName" placeholder="Enter class name" class="modal-input">
            <div class="modal-buttons">
                <button id="addClassConfirm" class="btn-primary">Add</button>
                <button id="addClassCancel" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <div id="shortcutsModal" class="modal">
        <div class="modal-content">
            <h3>Keyboard Shortcuts</h3>
            <div class="shortcuts-list">
                <div class="shortcut-item">
                    <kbd>Delete</kbd>
                    <span>Delete selected box</span>
                </div>
                <div class="shortcut-item">
                    <kbd>Escape</kbd>
                    <span>Deselect box / cancel drawing</span>
                </div>
                <div class="shortcut-item">
                    <kbd>‚Üê ‚Üí</kbd>
                    <span>Navigate between images</span>
                </div>
                <div class="shortcut-item">
                    <kbd>+ / -</kbd>
                    <span>Zoom in / out</span>
                </div>
                <div class="shortcut-item">
                    <kbd>0</kbd>
                    <span>Fit to screen</span>
                </div>
                <div class="shortcut-item">
                    <kbd>H</kbd>
                    <span>Toggle hide/show boxes</span>
                </div>
                <div class="shortcut-item">
                    <kbd>Ctrl+S</kbd>
                    <span>Save annotations</span>
                </div>
                <div class="shortcut-item">
                    <kbd>Space + Drag</kbd>
                    <span>Pan canvas</span>
                </div>
                <div class="shortcut-item">
                    <kbd>?</kbd>
                    <span>Show this help</span>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="shortcutsClose" class="btn-primary">Close</button>
            </div>
        </div>
    </div>

    <!-- Toast Notifications -->
    <div id="toastContainer" class="toast-container"></div>

    <script>
/**
 * FormatHandler.js
 * Base class for annotation format handlers
 * Defines the interface that all format handlers must implement
 */

class FormatHandler {
    /**
     * Get format name
     * @returns {string} Format identifier (e.g., 'yolo', 'coco')
     */
    getName() {
        throw new Error('Must implement getName()');
    }

    /**
     * Load annotations from folder
     * Each handler internally decides how to discover and read annotation files
     *
     * @param {FileManager} fileManager - File system manager
     * @param {Array} images - Array of image objects with {id, fileName, filePath, width, height}
     * @returns {Promise<Object>} - {boxes: Map<imageId, boxes[]>, classes: string[]}
     */
    async load(fileManager, images) {
        throw new Error('Must implement load()');
    }

    /**
     * Save annotations for current image
     * Each handler decides what files to write and how
     *
     * @param {FileManager} fileManager - File system manager
     * @param {Object} image - Image object {id, fileName, filePath, width, height}
     * @param {Array} boxes - Box objects with {classId, className, x, y, width, height}
     * @param {Array} classes - Class names array
     * @returns {Promise<void>}
     */
    async save(fileManager, image, boxes, classes) {
        throw new Error('Must implement save()');
    }

    /**
     * Get label file path for an image (optional, for per-image formats)
     * @param {string} imagePath - Image file path
     * @returns {string|null} - Label file path or null if format doesn't use per-image files
     */
    getLabelPath(imagePath) {
        return null;
    }
}

/**
 * YOLOHandler.js
 * Handles YOLO format parsing and writing
 * Format: <class_id> <center_x> <center_y> <width> <height>
 * All coordinates are normalized (0.0 to 1.0)
 */


class YOLOHandler extends FormatHandler {
    constructor() {
        super();
        this.classes = [];
    }

    /**
     * Get format name
     * @returns {string}
     */
    getName() {
        return 'yolo';
    }

    /**
     * Load all YOLO annotations from folder
     * @param {FileManager} fileManager
     * @param {Array} images - Array of image objects
     * @returns {Promise<Object>} - {boxes: Map<imageId, boxes[]>, classes: string[]}
     */
    async load(fileManager, images) {
        const boxes = new Map();

        // Try to load classes.txt from root or labels folder
        let classesContent = await fileManager.readTextFile('classes.txt');
        if (!classesContent) {
            classesContent = await fileManager.readTextFile('labels/classes.txt');
        }

        let classes = ['object'];
        if (classesContent) {
            classes = this.parseClasses(classesContent);
        }
        this.classes = classes;

        // Load annotations for each image
        for (const image of images) {
            const labelPath = this.getLabelPath(image.filePath);
            const content = await fileManager.readTextFile(labelPath);

            if (content) {
                const imageBoxes = this.parse(content, image.width, image.height);
                boxes.set(image.id, imageBoxes);
            }
        }

        // Infer classes from loaded boxes if classes.txt wasn't found
        if (classes.length === 1) {
            const allBoxes = Array.from(boxes.values()).flat();
            const maxClassId = Math.max(0, ...allBoxes.map(b => b.classId));

            if (maxClassId > 0) {
                classes = [];
                for (let i = 0; i <= maxClassId; i++) {
                    classes.push(`class_${i}`);
                }
                this.classes = classes;
            }
        }

        return { boxes, classes };
    }

    /**
     * Save YOLO annotations for current image
     * @param {FileManager} fileManager
     * @param {Object} image - Image object
     * @param {Array} boxes - Box objects
     * @param {Array} classes - Class names
     * @returns {Promise<void>}
     */
    async save(fileManager, image, boxes, classes) {
        // Save label file for this image
        const content = this.stringify(boxes, image.width, image.height);
        const labelPath = this.getLabelPath(image.filePath);
        await fileManager.writeTextFile(labelPath, content);

        // Save classes.txt if it doesn't exist
        const classesExist = await fileManager.fileExists('classes.txt');
        if (!classesExist) {
            this.classes = classes;
            const classesContent = this.stringifyClasses(classes);
            await fileManager.writeTextFile('classes.txt', classesContent);
        }
    }

    /**
     * Get label file path for an image
     * @param {string} imagePath - Image file path (e.g., "image1.jpg")
     * @returns {string} - Label file path (e.g., "image1.txt")
     */
    getLabelPath(imagePath) {
        const fileName = imagePath.substring(imagePath.lastIndexOf('/') + 1);
        const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
        return `${baseName}.txt`;
    }

    /**
     * Parse YOLO annotation text file
     * @param {string} content - Content of .txt file
     * @param {number} imageWidth - Image width in pixels
     * @param {number} imageHeight - Image height in pixels
     * @returns {Array} Array of box objects
     */
    parse(content, imageWidth, imageHeight) {
        const boxes = [];
        const lines = content.trim().split('\n').filter(line => line.trim());

        for (const line of lines) {
            const parts = line.trim().split(/\s+/);
            if (parts.length < 5) continue;

            const classId = parseInt(parts[0]);
            const centerX = parseFloat(parts[1]);
            const centerY = parseFloat(parts[2]);
            const width = parseFloat(parts[3]);
            const height = parseFloat(parts[4]);

            // Convert normalized coordinates to pixels
            const box = this.normalizedToPixels(
                { centerX, centerY, width, height },
                imageWidth,
                imageHeight
            );

            boxes.push({
                classId,
                className: this.classes[classId] || `class_${classId}`,
                x: box.x,
                y: box.y,
                width: box.width,
                height: box.height
            });
        }

        return boxes;
    }

    /**
     * Convert boxes to YOLO format string
     * @param {Array} boxes - Array of box objects
     * @param {number} imageWidth - Image width in pixels
     * @param {number} imageHeight - Image height in pixels
     * @returns {string} YOLO format string
     */
    stringify(boxes, imageWidth, imageHeight) {
        const lines = boxes.map(box => {
            const normalized = this.pixelsToNormalized(box, imageWidth, imageHeight);

            return [
                box.classId,
                normalized.centerX.toFixed(6),
                normalized.centerY.toFixed(6),
                normalized.width.toFixed(6),
                normalized.height.toFixed(6)
            ].join(' ');
        });

        return lines.join('\n') + (lines.length > 0 ? '\n' : '');
    }

    /**
     * Convert normalized YOLO coordinates to pixel coordinates
     * @param {Object} normalized - {centerX, centerY, width, height} all 0-1
     * @param {number} imageWidth - Image width
     * @param {number} imageHeight - Image height
     * @returns {Object} {x, y, width, height} in pixels (top-left origin)
     */
    normalizedToPixels(normalized, imageWidth, imageHeight) {
        const width = normalized.width * imageWidth;
        const height = normalized.height * imageHeight;
        const centerX = normalized.centerX * imageWidth;
        const centerY = normalized.centerY * imageHeight;

        return {
            x: centerX - width / 2,
            y: centerY - height / 2,
            width,
            height
        };
    }

    /**
     * Convert pixel coordinates to normalized YOLO coordinates
     * @param {Object} box - {x, y, width, height} in pixels (top-left origin)
     * @param {number} imageWidth - Image width
     * @param {number} imageHeight - Image height
     * @returns {Object} {centerX, centerY, width, height} all 0-1
     */
    pixelsToNormalized(box, imageWidth, imageHeight) {
        const centerX = (box.x + box.width / 2) / imageWidth;
        const centerY = (box.y + box.height / 2) / imageHeight;
        const width = box.width / imageWidth;
        const height = box.height / imageHeight;

        return {
            centerX: Math.max(0, Math.min(1, centerX)),
            centerY: Math.max(0, Math.min(1, centerY)),
            width: Math.max(0, Math.min(1, width)),
            height: Math.max(0, Math.min(1, height))
        };
    }

    /**
     * Parse classes.txt file
     * @param {string} content - Content of classes.txt
     * @returns {Array} Array of class names
     */
    parseClasses(content) {
        this.classes = content
            .trim()
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);
        return this.classes;
    }

    /**
     * Generate classes.txt content
     * @param {Array} classes - Array of class names
     * @returns {string} classes.txt content
     */
    stringifyClasses(classes) {
        return classes.join('\n') + '\n';
    }

    /**
     * Set classes array
     * @param {Array} classes - Array of class names
     */
    setClasses(classes) {
        this.classes = classes;
    }

    /**
     * Get classes array
     * @returns {Array} Array of class names
     */
    getClasses() {
        return this.classes;
    }
}

/**
 * COCOHandler.js
 * Handles COCO format parsing and writing
 * Format: Single JSON file with images, annotations, and categories
 * bbox format: [top_left_x, top_left_y, width, height] in pixels
 * Note: COCO uses 1-indexed category IDs, but internally we use 0-indexed
 */


class COCOHandler extends FormatHandler {
    constructor() {
        super();
        this.data = {
            images: [],
            annotations: [],
            categories: []
        };
        this.nextImageId = 1;
        this.nextAnnotationId = 1;
        this.imageIdMap = new Map(); // fileName -> imageId
        this.annotationFile = 'annotations.json'; // Track which file to save to
    }

    /**
     * Get format name
     * @returns {string}
     */
    getName() {
        return 'coco';
    }

    /**
     * Load all COCO annotations from folder
     * @param {FileManager} fileManager
     * @param {Array} images - Array of image objects
     * @returns {Promise<Object>} - {boxes: Map<imageId, boxes[]>, classes: string[]}
     */
    async load(fileManager, images) {
        const boxes = new Map();

        // Try to find COCO annotations file with various common names
        const possibleNames = [
            'annotations.json',
            '_annotations.coco.json',
            'instances_default.json',
            'instances.json'
        ];

        let content = null;
        for (const name of possibleNames) {
            content = await fileManager.readTextFile(name);
            if (content) {
                console.log(`Found COCO annotations: ${name}`);
                this.annotationFile = name;
                break;
            }
        }

        let classes = ['object'];

        if (content) {
            this.parse(content);

            // Load categories (classes)
            const categories = this.getCategories();
            if (categories.length > 0) {
                classes = categories.map(cat => cat.name);
            }

            // Create mapping from COCO category ID to internal class index
            // COCO category IDs can be non-sequential (e.g., 1, 5, 47)
            const categoryIdToIndex = new Map();
            categories.forEach((cat, index) => {
                categoryIdToIndex.set(cat.id, index);
            });

            // Load annotations for each image
            for (const image of images) {
                const imageBoxes = this.getBoxesForImage(image.fileName);

                // Convert COCO category IDs to internal 0-indexed class IDs
                const normalizedBoxes = imageBoxes.map(box => {
                    const classIndex = categoryIdToIndex.get(box.classId);
                    return {
                        ...box,
                        classId: classIndex !== undefined ? classIndex : 0
                    };
                });

                boxes.set(image.id, normalizedBoxes);
            }
        } else {
            // No annotation file found - initialize empty dataset
            console.log('No COCO annotations found. Starting with empty dataset.');
            this.annotationFile = '_annotations.coco.json';
            this.initEmpty();
        }

        return { boxes, classes };
    }

    /**
     * Save COCO annotations for current image
     * @param {FileManager} fileManager
     * @param {Object} image - Image object
     * @param {Array} boxes - Box objects with 0-indexed class IDs
     * @param {Array} classes - Class names
     * @returns {Promise<void>}
     */
    async save(fileManager, image, boxes, classes) {
        // Set categories
        const cocoCategories = classes.map((name, index) => ({
            id: index + 1, // COCO uses 1-indexed category IDs
            name: name,
            supercategory: 'none'
        }));
        this.setCategories(cocoCategories);

        // Convert 0-indexed to COCO 1-indexed class IDs
        const cocoBoxes = boxes.map(box => ({
            ...box,
            classId: box.classId + 1
        }));

        this.setBoxesForImage(
            image.fileName,
            cocoBoxes,
            image.width,
            image.height
        );

        // Write to the same file that was loaded
        const content = this.stringify();
        await fileManager.writeTextFile(this.annotationFile, content);
    }

    /**
     * Parse COCO JSON file
     * @param {string} content - JSON content
     * @returns {Object} Parsed data structure
     */
    parse(content) {
        try {
            this.data = JSON.parse(content);

            // Ensure required fields exist
            if (!this.data.images) this.data.images = [];
            if (!this.data.annotations) this.data.annotations = [];
            if (!this.data.categories) this.data.categories = [];

            // Build image ID map
            this.imageIdMap.clear();
            this.data.images.forEach(img => {
                this.imageIdMap.set(img.file_name, img.id);
            });

            // Find next available IDs
            const maxImageId = Math.max(0, ...this.data.images.map(img => img.id));
            const maxAnnotationId = Math.max(0, ...this.data.annotations.map(ann => ann.id));
            this.nextImageId = maxImageId + 1;
            this.nextAnnotationId = maxAnnotationId + 1;

            return this.data;
        } catch (error) {
            console.error('Error parsing COCO JSON:', error);
            throw new Error('Invalid COCO JSON format');
        }
    }

    /**
     * Convert COCO data to JSON string
     * @returns {string} Formatted JSON string
     */
    stringify() {
        return JSON.stringify(this.data, null, 2);
    }

    /**
     * Get boxes for a specific image
     * @param {string} fileName - Image file name
     * @returns {Array} Array of box objects
     */
    getBoxesForImage(fileName) {
        const imageId = this.imageIdMap.get(fileName);
        if (imageId === undefined || imageId === null) return [];

        const boxes = this.data.annotations
            .filter(ann => ann.image_id === imageId)
            .map(ann => {
                const category = this.data.categories.find(cat => cat.id === ann.category_id);
                return {
                    id: ann.id,
                    classId: ann.category_id,
                    className: category ? category.name : `category_${ann.category_id}`,
                    x: ann.bbox[0],
                    y: ann.bbox[1],
                    width: ann.bbox[2],
                    height: ann.bbox[3]
                };
            });

        return boxes;
    }

    /**
     * Update boxes for an image
     * @param {string} fileName - Image file name
     * @param {Array} boxes - Array of box objects
     * @param {number} imageWidth - Image width
     * @param {number} imageHeight - Image height
     */
    setBoxesForImage(fileName, boxes, imageWidth, imageHeight) {
        // Ensure image exists in dataset
        let imageId = this.imageIdMap.get(fileName);
        if (imageId === undefined || imageId === null) {
            imageId = this.addImage(fileName, imageWidth, imageHeight);
        }

        // Remove existing annotations for this image
        this.data.annotations = this.data.annotations.filter(ann => ann.image_id !== imageId);

        // Add new annotations
        boxes.forEach(box => {
            const annotation = {
                id: box.id || this.nextAnnotationId++,
                image_id: imageId,
                category_id: box.classId,
                bbox: [box.x, box.y, box.width, box.height],
                area: box.width * box.height,
                iscrowd: 0
            };
            this.data.annotations.push(annotation);
        });
    }

    /**
     * Add an image to the dataset
     * @param {string} fileName - Image file name
     * @param {number} width - Image width
     * @param {number} height - Image height
     * @returns {number} Image ID
     */
    addImage(fileName, width, height) {
        const imageId = this.nextImageId++;
        this.data.images.push({
            id: imageId,
            file_name: fileName,
            width,
            height
        });
        this.imageIdMap.set(fileName, imageId);
        return imageId;
    }

    /**
     * Get categories (classes)
     * @returns {Array} Array of category objects
     */
    getCategories() {
        return this.data.categories;
    }

    /**
     * Add a category
     * @param {string} name - Category name
     * @param {string} supercategory - Super category (default: "none")
     * @returns {number} Category ID
     */
    addCategory(name, supercategory = "none") {
        const maxId = Math.max(0, ...this.data.categories.map(cat => cat.id));
        const newId = maxId + 1;

        this.data.categories.push({
            id: newId,
            name,
            supercategory
        });

        return newId;
    }

    /**
     * Set categories
     * @param {Array} categories - Array of category objects {id, name, supercategory}
     */
    setCategories(categories) {
        this.data.categories = categories;
    }

    /**
     * Get category name by ID
     * @param {number} categoryId - Category ID
     * @returns {string} Category name
     */
    getCategoryName(categoryId) {
        const category = this.data.categories.find(cat => cat.id === categoryId);
        return category ? category.name : `category_${categoryId}`;
    }

    /**
     * Get category ID by name
     * @param {string} name - Category name
     * @returns {number|null} Category ID or null if not found
     */
    getCategoryId(name) {
        const category = this.data.categories.find(cat => cat.name === name);
        return category ? category.id : null;
    }

    /**
     * Initialize empty COCO dataset
     */
    initEmpty() {
        this.data = {
            images: [],
            annotations: [],
            categories: []
        };
        this.nextImageId = 1;
        this.nextAnnotationId = 1;
        this.imageIdMap.clear();
    }

    /**
     * Get full COCO data structure
     * @returns {Object} COCO data
     */
    getData() {
        return this.data;
    }
}

/**
 * AnnotationStore.js
 * Manages in-memory data model for annotations
 * Tracks modifications and provides CRUD operations
 */

class AnnotationStore {
    constructor() {
        this.state = {
            format: 'yolo',
            folderHandle: null,
            images: new Map(),
            boxes: new Map(),
            classes: [],
            currentImageId: null,
            selectedBoxId: null,
            currentClassId: 0,
            zoom: 1.0,
            panX: 0,
            panY: 0,
            showBoxes: true,
            currentImageModified: false
        };

        this.listeners = new Map();
        this.nextBoxId = 1;
        this.nextImageId = 1;
        this.savedBoxesState = null; // Stores original boxes for current image
    }

    /**
     * Get current state
     * @returns {Object} Application state
     */
    getState() {
        return this.state;
    }

    /**
     * Set format (yolo or coco)
     * @param {string} format - Format type
     */
    setFormat(format) {
        this.state.format = format;
        this.notify('format', format);
    }

    /**
     * Set folder handle
     * @param {FileSystemDirectoryHandle} handle - Folder handle
     */
    setFolderHandle(handle) {
        this.state.folderHandle = handle;
        this.notify('folderHandle', handle);
    }

    /**
     * Add or update an image
     * @param {Object} imageData - Image data object
     * @returns {string} Image ID
     */
    addImage(imageData) {
        const id = imageData.id || `img_${this.nextImageId++}`;
        const image = {
            id,
            fileName: imageData.fileName,
            filePath: imageData.filePath,
            width: imageData.width,
            height: imageData.height,
            boxes: imageData.boxes || []
        };

        this.state.images.set(id, image);
        this.notify('images', this.state.images);
        return id;
    }

    /**
     * Get image by ID
     * @param {string} imageId - Image ID
     * @returns {Object|null} Image object
     */
    getImage(imageId) {
        return this.state.images.get(imageId) || null;
    }

    /**
     * Get all images
     * @returns {Array} Array of image objects
     */
    getAllImages() {
        return Array.from(this.state.images.values());
    }

    /**
     * Add a box
     * @param {Object} boxData - Box data
     * @returns {string} Box ID
     */
    addBox(boxData) {
        const id = boxData.id || `box_${this.nextBoxId++}`;
        const box = {
            id,
            classId: boxData.classId,
            className: boxData.className,
            x: boxData.x,
            y: boxData.y,
            width: boxData.width,
            height: boxData.height,
            imageId: boxData.imageId
        };

        this.state.boxes.set(id, box);

        // Add box reference to image
        const image = this.state.images.get(box.imageId);
        if (image) {
            if (!image.boxes.includes(id)) {
                image.boxes.push(id);
            }
            this.markImageModified(box.imageId);
        }

        this.notify('boxes', this.state.boxes);
        return id;
    }

    /**
     * Update a box
     * @param {string} boxId - Box ID
     * @param {Object} updates - Properties to update
     */
    updateBox(boxId, updates) {
        const box = this.state.boxes.get(boxId);
        if (!box) return;

        Object.assign(box, updates);
        this.markImageModified(box.imageId);
        this.notify('boxes', this.state.boxes);
    }

    /**
     * Delete a box
     * @param {string} boxId - Box ID
     */
    deleteBox(boxId) {
        const box = this.state.boxes.get(boxId);
        if (!box) return;

        // Remove from image
        const image = this.state.images.get(box.imageId);
        if (image) {
            image.boxes = image.boxes.filter(id => id !== boxId);
            this.markImageModified(box.imageId);
        }

        this.state.boxes.delete(boxId);

        // Deselect if this was selected
        if (this.state.selectedBoxId === boxId) {
            this.state.selectedBoxId = null;
        }

        this.notify('boxes', this.state.boxes);
    }

    /**
     * Get box by ID
     * @param {string} boxId - Box ID
     * @returns {Object|null} Box object
     */
    getBox(boxId) {
        return this.state.boxes.get(boxId) || null;
    }

    /**
     * Get boxes for an image
     * @param {string} imageId - Image ID
     * @returns {Array} Array of box objects
     */
    getBoxesForImage(imageId) {
        const image = this.state.images.get(imageId);
        if (!image) return [];

        return image.boxes
            .map(boxId => this.state.boxes.get(boxId))
            .filter(box => box);
    }

    /**
     * Set classes
     * @param {Array} classes - Array of class names
     */
    setClasses(classes) {
        this.state.classes = classes;
        this.notify('classes', classes);
    }

    /**
     * Add a class
     * @param {string} className - Class name
     * @returns {number} Class ID
     */
    addClass(className) {
        const classId = this.state.classes.length;
        this.state.classes.push(className);
        this.notify('classes', this.state.classes);
        return classId;
    }

    /**
     * Get classes
     * @returns {Array} Array of class names
     */
    getClasses() {
        return this.state.classes;
    }

    /**
     * Set current image
     * @param {string} imageId - Image ID
     */
    setCurrentImage(imageId) {
        // Discard any unsaved changes to the previous image
        if (this.state.currentImageId && this.state.currentImageModified) {
            this.discardCurrentImageEdits();
        }

        this.state.currentImageId = imageId;
        this.state.selectedBoxId = null;
        this.state.currentImageModified = false;

        // Save the current state of boxes for this image
        this.saveCurrentImageState();

        this.notify('currentImage', imageId);
        this.notify('modified', this.state.currentImageModified);
    }

    /**
     * Get current image
     * @returns {Object|null} Current image object
     */
    getCurrentImage() {
        return this.getImage(this.state.currentImageId);
    }

    /**
     * Set selected box
     * @param {string|null} boxId - Box ID or null
     */
    setSelectedBox(boxId) {
        this.state.selectedBoxId = boxId;
        this.notify('selectedBox', boxId);
    }

    /**
     * Get selected box
     * @returns {Object|null} Selected box object
     */
    getSelectedBox() {
        return this.getBox(this.state.selectedBoxId);
    }

    /**
     * Set current class
     * @param {number} classId - Class ID
     */
    setCurrentClass(classId) {
        this.state.currentClassId = classId;
        this.notify('currentClass', classId);
    }

    /**
     * Mark image as modified (only tracks current image)
     * @param {string} imageId - Image ID
     */
    markImageModified(imageId) {
        // Only track modifications for the current image
        if (imageId === this.state.currentImageId) {
            this.state.currentImageModified = true;
            this.notify('modified', this.state.currentImageModified);
        }
    }

    /**
     * Clear modified flag for current image after save
     */
    clearImageModified() {
        this.state.currentImageModified = false;
        // Update saved state to match current state
        this.saveCurrentImageState();
        this.notify('modified', this.state.currentImageModified);
    }

    /**
     * Check if current image has unsaved changes
     * @returns {boolean} True if modified
     */
    isCurrentImageModified() {
        return this.state.currentImageModified;
    }

    /**
     * Set zoom level
     * @param {number} zoom - Zoom level
     */
    setZoom(zoom) {
        this.state.zoom = zoom;
        this.notify('zoom', zoom);
    }

    /**
     * Set pan offset
     * @param {number} x - Pan X
     * @param {number} y - Pan Y
     */
    setPan(x, y) {
        this.state.panX = x;
        this.state.panY = y;
        this.notify('pan', { x, y });
    }

    /**
     * Toggle box visibility
     */
    toggleBoxVisibility() {
        this.state.showBoxes = !this.state.showBoxes;
        this.notify('showBoxes', this.state.showBoxes);
    }

    /**
     * Clear all data
     */
    clear() {
        this.state.images.clear();
        this.state.boxes.clear();
        this.state.classes = [];
        this.state.currentImageId = null;
        this.state.selectedBoxId = null;
        this.state.currentImageModified = false;
        this.savedBoxesState = null;
        this.nextBoxId = 1;
        this.nextImageId = 1;
        this.notify('clear', null);
    }

    /**
     * Save current image state for potential rollback
     */
    saveCurrentImageState() {
        if (!this.state.currentImageId) {
            this.savedBoxesState = null;
            return;
        }

        const image = this.state.images.get(this.state.currentImageId);
        if (!image) {
            this.savedBoxesState = null;
            return;
        }

        // Deep copy of current boxes for this image
        this.savedBoxesState = image.boxes.map(boxId => {
            const box = this.state.boxes.get(boxId);
            return box ? { ...box } : null;
        }).filter(box => box !== null);
    }

    /**
     * Discard edits to current image and restore saved state
     */
    discardCurrentImageEdits() {
        if (!this.state.currentImageId || !this.savedBoxesState) {
            return;
        }

        const image = this.state.images.get(this.state.currentImageId);
        if (!image) return;

        // Remove all current boxes for this image
        const currentBoxIds = [...image.boxes];
        currentBoxIds.forEach(boxId => {
            this.state.boxes.delete(boxId);
        });

        // Restore saved boxes
        image.boxes = [];
        this.savedBoxesState.forEach(savedBox => {
            const boxId = `box_${this.nextBoxId++}`;
            const box = {
                ...savedBox,
                id: boxId
            };
            this.state.boxes.set(boxId, box);
            image.boxes.push(boxId);
        });

        // Clear modified flag
        this.state.currentImageModified = false;

        // Notify listeners
        this.notify('boxes', this.state.boxes);
        this.notify('modified', this.state.currentImageModified);
    }

    /**
     * Subscribe to state changes
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }

    /**
     * Unsubscribe from state changes
     * @param {string} event - Event name
     * @param {Function} callback - Callback function
     */
    off(event, callback) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }

    /**
     * Notify listeners of state change
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    notify(event, data) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.forEach(callback => callback(data));
        }
    }
}

/**
 * FileManager.js
 * Handles file system operations using File System Access API
 * with drag-drop fallback for unsupported browsers
 */

class FileManager {
    constructor() {
        this.hasFileSystemAccess = 'showDirectoryPicker' in window;
        this.imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'];
        this.directoryHandle = null;
        this.fileCache = new Map(); // fileName -> FileHandle
    }

    /**
     * Check if File System Access API is supported
     * @returns {boolean} True if supported
     */
    isFileSystemAccessSupported() {
        return this.hasFileSystemAccess;
    }

    /**
     * Open a folder dialog and load images
     * @returns {Promise<Array>} Array of image file data
     */
    async openFolder() {
        if (this.hasFileSystemAccess) {
            return await this.openFolderWithAPI();
        } else {
            throw new Error('File System Access API not supported. Use drag-and-drop fallback.');
        }
    }

    /**
     * Open folder using File System Access API
     * @returns {Promise<Array>} Array of image file data
     */
    async openFolderWithAPI() {
        try {
            this.directoryHandle = await window.showDirectoryPicker({
                mode: 'readwrite'
            });

            const files = await this.scanDirectory(this.directoryHandle);
            return files;
        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('Folder selection cancelled');
            }
            throw error;
        }
    }

    /**
     * Recursively scan directory for image files
     * @param {FileSystemDirectoryHandle} dirHandle - Directory handle
     * @param {string} relativePath - Relative path from root
     * @returns {Promise<Array>} Array of file data
     */
    async scanDirectory(dirHandle, relativePath = '') {
        const files = [];

        try {
            for await (const entry of dirHandle.values()) {
                const path = relativePath ? `${relativePath}/${entry.name}` : entry.name;

                if (entry.kind === 'file') {
                    const ext = this.getFileExtension(entry.name);
                    if (this.imageExtensions.includes(ext)) {
                        const fileHandle = await dirHandle.getFileHandle(entry.name);
                        const file = await fileHandle.getFile();

                        files.push({
                            name: entry.name,
                            path: path,
                            file: file,
                            handle: fileHandle
                        });

                        this.fileCache.set(path, fileHandle);
                    }
                }
                // Skip subdirectories - only scan root folder
            }
        } catch (error) {
            console.error('Error scanning directory:', error);
        }

        return files;
    }

    /**
     * Read a text file (annotations, classes)
     * @param {string} fileName - File name relative to root
     * @returns {Promise<string>} File content
     */
    async readTextFile(fileName) {
        try {
            const fileHandle = await this.getFileHandle(fileName);
            if (!fileHandle) return null;

            const file = await fileHandle.getFile();
            return await file.text();
        } catch (error) {
            console.error(`Error reading file ${fileName}:`, error);
            return null;
        }
    }

    /**
     * Write a text file
     * @param {string} fileName - File name relative to root
     * @param {string} content - File content
     */
    async writeTextFile(fileName, content) {
        try {
            const fileHandle = await this.getOrCreateFileHandle(fileName);
            const writable = await fileHandle.createWritable();
            await writable.write(content);
            await writable.close();
        } catch (error) {
            console.error(`Error writing file ${fileName}:`, error);
            throw error;
        }
    }

    /**
     * Get file handle for a path
     * @param {string} filePath - File path relative to root
     * @returns {Promise<FileSystemFileHandle|null>} File handle
     */
    async getFileHandle(filePath) {
        if (this.fileCache.has(filePath)) {
            return this.fileCache.get(filePath);
        }

        if (!this.directoryHandle) return null;

        try {
            const parts = filePath.split('/');
            let currentHandle = this.directoryHandle;

            // Navigate through directories
            for (let i = 0; i < parts.length - 1; i++) {
                currentHandle = await currentHandle.getDirectoryHandle(parts[i]);
            }

            // Get file handle
            const fileName = parts[parts.length - 1];
            const fileHandle = await currentHandle.getFileHandle(fileName);
            this.fileCache.set(filePath, fileHandle);
            return fileHandle;
        } catch (error) {
            return null;
        }
    }

    /**
     * Get or create file handle
     * @param {string} filePath - File path relative to root
     * @returns {Promise<FileSystemFileHandle>} File handle
     */
    async getOrCreateFileHandle(filePath) {
        let fileHandle = await this.getFileHandle(filePath);
        if (fileHandle) return fileHandle;

        if (!this.directoryHandle) {
            throw new Error('No directory handle available');
        }

        try {
            const parts = filePath.split('/');
            let currentHandle = this.directoryHandle;

            // Navigate/create directories
            for (let i = 0; i < parts.length - 1; i++) {
                try {
                    currentHandle = await currentHandle.getDirectoryHandle(parts[i]);
                } catch {
                    currentHandle = await currentHandle.getDirectoryHandle(parts[i], { create: true });
                }
            }

            // Create file
            const fileName = parts[parts.length - 1];
            fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
            this.fileCache.set(filePath, fileHandle);
            return fileHandle;
        } catch (error) {
            console.error(`Error creating file ${filePath}:`, error);
            throw error;
        }
    }

    /**
     * Load image as data URL
     * @param {File} file - Image file
     * @returns {Promise<Object>} Image data with URL and dimensions
     */
    async loadImage(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    resolve({
                        url: e.target.result,
                        width: img.width,
                        height: img.height
                    });
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    /**
     * Get file extension from filename
     * @param {string} fileName - File name
     * @returns {string} Extension (lowercase, without dot)
     */
    getFileExtension(fileName) {
        const parts = fileName.split('.');
        return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : '';
    }

    /**
     * Check if file exists
     * @param {string} filePath - File path relative to root
     * @returns {Promise<boolean>} True if file exists
     */
    async fileExists(filePath) {
        const handle = await this.getFileHandle(filePath);
        return handle !== null;
    }

    /**
     * Get directory name from directory handle
     * @returns {string} Directory name
     */
    getDirectoryName() {
        return this.directoryHandle ? this.directoryHandle.name : '';
    }

    /**
     * Clear all cached file handles
     * Call this when loading a new folder to prevent reading stale files
     */
    clear() {
        this.fileCache.clear();
        this.directoryHandle = null;
    }

    /**
     * Handle drag and drop events (fallback for unsupported browsers)
     * @param {DataTransfer} dataTransfer - Drag data transfer object
     * @returns {Promise<Array>} Array of image files
     */
    async handleDragDrop(dataTransfer) {
        const files = [];
        const items = dataTransfer.items;

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    await this.traverseEntry(entry, files, '');
                }
            }
        }

        return files;
    }

    /**
     * Recursively traverse file system entry
     * @param {FileSystemEntry} entry - File system entry
     * @param {Array} files - Accumulator for files
     * @param {string} path - Current path
     */
    async traverseEntry(entry, files, path) {
        if (entry.isFile) {
            const ext = this.getFileExtension(entry.name);
            if (this.imageExtensions.includes(ext)) {
                const file = await new Promise((resolve, reject) => {
                    entry.file(resolve, reject);
                });

                files.push({
                    name: entry.name,
                    path: path ? `${path}/${entry.name}` : entry.name,
                    file: file,
                    subfolder: path
                });
            }
        } else if (entry.isDirectory) {
            const reader = entry.createReader();
            const entries = await new Promise((resolve, reject) => {
                reader.readEntries(resolve, reject);
            });

            for (const subEntry of entries) {
                const subPath = path ? `${path}/${entry.name}` : entry.name;
                await this.traverseEntry(subEntry, files, subPath);
            }
        }
    }
}

/**
 * ImageCanvas.js
 * Handles canvas rendering, zoom/pan, and coordinate transformations
 */

class ImageCanvas {
    constructor(canvasElement, store) {
        this.canvas = canvasElement;
        this.ctx = canvasElement.getContext('2d');
        this.store = store;

        this.image = null;
        this.imageWidth = 0;
        this.imageHeight = 0;

        // Zoom and pan state
        this.zoom = 1.0;
        this.panX = 0;
        this.panY = 0;
        this.offsetX = 0; // Offset to center image
        this.offsetY = 0;

        // Color palette for classes (HSL with consistent saturation/lightness)
        this.colorPalette = this.generateColorPalette(20);

        this.setupCanvas();
    }

    /**
     * Generate color palette using HSL
     * @param {number} count - Number of colors
     * @returns {Array} Array of color strings
     */
    generateColorPalette(count) {
        const colors = [];
        const saturation = 70;
        const lightness = 50;

        for (let i = 0; i < count; i++) {
            // Start with purple (270¬∞) instead of red (0¬∞)
            const hue = (270 + i * 360 / count) % 360;
            colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }

        return colors;
    }

    /**
     * Setup canvas size
     */
    setupCanvas() {
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
    }

    /**
     * Resize canvas to container
     */
    resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.render();
    }

    /**
     * Load and display an image
     * @param {string} imageUrl - Image URL or data URL
     * @param {number} width - Image width
     * @param {number} height - Image height
     */
    async loadImage(imageUrl, width, height) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                this.image = img;
                this.imageWidth = width;
                this.imageHeight = height;
                this.fitToScreen();
                this.render();
                resolve();
            };
            img.onerror = reject;
            img.src = imageUrl;
        });
    }

    /**
     * Fit image to screen
     */
    fitToScreen() {
        if (!this.image) return;

        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;

        const scaleX = (canvasWidth - 40) / this.imageWidth;
        const scaleY = (canvasHeight - 40) / this.imageHeight;

        this.zoom = Math.min(scaleX, scaleY, 1.0);
        this.panX = 0;
        this.panY = 0;

        // Center image
        this.offsetX = (canvasWidth - this.imageWidth * this.zoom) / 2;
        this.offsetY = (canvasHeight - this.imageHeight * this.zoom) / 2;

        this.store.setZoom(this.zoom);
        this.store.setPan(this.panX, this.panY);
    }

    /**
     * Zoom in/out
     * @param {number} delta - Zoom delta
     * @param {number} centerX - Center X in screen coordinates
     * @param {number} centerY - Center Y in screen coordinates
     */
    zoomAt(delta, centerX, centerY) {
        const oldZoom = this.zoom;

        // Apply zoom
        if (delta > 0) {
            this.zoom *= 1.2;
        } else {
            this.zoom /= 1.2;
        }

        // Clamp zoom
        this.zoom = Math.max(0.1, Math.min(5.0, this.zoom));

        // Adjust pan to zoom towards center point
        // Account for the static offset when calculating zoom center
        const zoomRatio = this.zoom / oldZoom;
        const adjustedCenterX = centerX - this.offsetX;
        const adjustedCenterY = centerY - this.offsetY;
        this.panX = adjustedCenterX - (adjustedCenterX - this.panX) * zoomRatio;
        this.panY = adjustedCenterY - (adjustedCenterY - this.panY) * zoomRatio;

        this.store.setZoom(this.zoom);
        this.store.setPan(this.panX, this.panY);
        this.render();
    }

    /**
     * Set zoom to specific level
     * @param {number} level - Zoom level (0.25, 0.5, 1.0, etc.)
     */
    setZoom(level) {
        this.zoom = level;
        this.store.setZoom(this.zoom);
        this.render();
    }

    /**
     * Pan the view
     * @param {number} dx - Delta X
     * @param {number} dy - Delta Y
     */
    pan(dx, dy) {
        this.panX += dx;
        this.panY += dy;
        this.store.setPan(this.panX, this.panY);
        this.render();
    }

    /**
     * Convert screen coordinates to image coordinates
     * @param {number} screenX - Screen X
     * @param {number} screenY - Screen Y
     * @returns {Object} {x, y} in image coordinates
     */
    screenToImage(screenX, screenY) {
        const x = (screenX - this.offsetX - this.panX) / this.zoom;
        const y = (screenY - this.offsetY - this.panY) / this.zoom;
        return { x, y };
    }

    /**
     * Convert image coordinates to screen coordinates
     * @param {number} imageX - Image X
     * @param {number} imageY - Image Y
     * @returns {Object} {x, y} in screen coordinates
     */
    imageToScreen(imageX, imageY) {
        const x = imageX * this.zoom + this.offsetX + this.panX;
        const y = imageY * this.zoom + this.offsetY + this.panY;
        return { x, y };
    }

    /**
     * Get color for a class
     * @param {number} classId - Class ID
     * @returns {string} Color string
     */
    getClassColor(classId) {
        return this.colorPalette[classId % this.colorPalette.length];
    }

    /**
     * Convert HSL color to HSLA with alpha
     * @param {string} hslColor - HSL color string (e.g., "hsl(180, 70%, 50%)")
     * @param {number} alpha - Alpha value (0-1)
     * @returns {string} HSLA color string
     */
    hslToHsla(hslColor, alpha) {
        // Convert hsl(h, s%, l%) to hsla(h, s%, l%, alpha)
        return hslColor.replace('hsl(', 'hsla(').replace(')', `, ${alpha})`);
    }

    /**
     * Main render function
     */
    render() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.image) return;

        // Draw image
        this.ctx.save();
        this.ctx.translate(this.offsetX + this.panX, this.offsetY + this.panY);
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.drawImage(this.image, 0, 0, this.imageWidth, this.imageHeight);
        this.ctx.restore();

        // Draw boxes
        if (this.store.getState().showBoxes) {
            this.renderBoxes();
        }
    }

    /**
     * Render all bounding boxes
     */
    renderBoxes() {
        const currentImage = this.store.getCurrentImage();
        if (!currentImage) return;

        const boxes = this.store.getBoxesForImage(currentImage.id);
        const selectedBoxId = this.store.getState().selectedBoxId;

        // Draw unselected boxes first
        boxes.forEach(box => {
            if (box.id !== selectedBoxId) {
                this.renderBox(box, false);
            }
        });

        // Draw selected box last (on top)
        if (selectedBoxId) {
            const selectedBox = this.store.getBox(selectedBoxId);
            if (selectedBox) {
                this.renderBox(selectedBox, true);
            }
        }
    }

    /**
     * Render a single box
     * @param {Object} box - Box object
     * @param {boolean} selected - Is selected
     */
    renderBox(box, selected) {
        const color = this.getClassColor(box.classId);
        const topLeft = this.imageToScreen(box.x, box.y);
        const bottomRight = this.imageToScreen(box.x + box.width, box.y + box.height);

        const screenWidth = bottomRight.x - topLeft.x;
        const screenHeight = bottomRight.y - topLeft.y;

        this.ctx.save();

        // Draw box
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = selected ? 3 : 2;
        this.ctx.setLineDash(selected ? [] : []);
        this.ctx.strokeRect(topLeft.x, topLeft.y, screenWidth, screenHeight);

        // Draw semi-transparent fill if selected
        if (selected) {
            this.ctx.fillStyle = this.hslToHsla(color, 0.12);
            this.ctx.fillRect(topLeft.x, topLeft.y, screenWidth, screenHeight);
        }

        // Draw label
        const label = box.className || `Class ${box.classId}`;
        this.ctx.font = '12px sans-serif';
        const textMetrics = this.ctx.measureText(label);
        const textWidth = textMetrics.width;
        const textHeight = 16;

        // Background for text
        this.ctx.fillStyle = color;
        this.ctx.fillRect(topLeft.x, topLeft.y - textHeight - 2, textWidth + 8, textHeight + 2);

        // Text
        this.ctx.fillStyle = 'white';
        this.ctx.fillText(label, topLeft.x + 4, topLeft.y - 4);

        // Draw handles if selected
        if (selected) {
            this.renderHandles(topLeft.x, topLeft.y, screenWidth, screenHeight, color);
        }

        this.ctx.restore();
    }

    /**
     * Render resize handles
     * @param {number} x - Top-left X
     * @param {number} y - Top-left Y
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {string} color - Handle color
     */
    renderHandles(x, y, width, height, color) {
        const handleSize = 8;
        const handles = this.getHandlePositions(x, y, width, height);

        this.ctx.fillStyle = 'white';
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;

        handles.forEach(handle => {
            this.ctx.fillRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
            this.ctx.strokeRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
        });
    }

    /**
     * Get handle positions for a box
     * @param {number} x - Top-left X
     * @param {number} y - Top-left Y
     * @param {number} width - Width
     * @param {number} height - Height
     * @returns {Array} Array of handle objects
     */
    getHandlePositions(x, y, width, height) {
        return [
            { type: 'nw', x: x, y: y },
            { type: 'n', x: x + width / 2, y: y },
            { type: 'ne', x: x + width, y: y },
            { type: 'e', x: x + width, y: y + height / 2 },
            { type: 'se', x: x + width, y: y + height },
            { type: 's', x: x + width / 2, y: y + height },
            { type: 'sw', x: x, y: y + height },
            { type: 'w', x: x, y: y + height / 2 }
        ];
    }

    /**
     * Draw crosshair cursor
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    drawCrosshair(x, y) {
        this.render();

        this.ctx.save();
        this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([5, 5]);

        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(x, 0);
        this.ctx.lineTo(x, this.canvas.height);
        this.ctx.stroke();

        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(this.canvas.width, y);
        this.ctx.stroke();

        // Center dot
        this.ctx.fillStyle = 'red';
        this.ctx.beginPath();
        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
        this.ctx.fill();

        this.ctx.restore();
    }

    /**
     * Draw preview box while creating
     * @param {number} x1 - Start X in image coords
     * @param {number} y1 - Start Y in image coords
     * @param {number} x2 - End X in image coords
     * @param {number} y2 - End Y in image coords
     */
    drawPreviewBox(x1, y1, x2, y2) {
        this.render();

        const currentClassId = this.store.getState().currentClassId;
        const color = this.getClassColor(currentClassId);

        const topLeft = this.imageToScreen(Math.min(x1, x2), Math.min(y1, y2));
        const bottomRight = this.imageToScreen(Math.max(x1, x2), Math.max(y1, y2));

        const width = bottomRight.x - topLeft.x;
        const height = bottomRight.y - topLeft.y;

        this.ctx.save();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        this.ctx.strokeRect(topLeft.x, topLeft.y, width, height);

        this.ctx.fillStyle = this.hslToHsla(color, 0.12);
        this.ctx.fillRect(topLeft.x, topLeft.y, width, height);
        this.ctx.restore();
    }

    /**
     * Clear the canvas
     */
    clear() {
        this.image = null;
        this.imageWidth = 0;
        this.imageHeight = 0;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

/**
 * BoxEditor.js
 * Handles mouse interactions for box creation, selection, and editing
 */

class BoxEditor {
    constructor(canvas, imageCanvas, store) {
        this.canvas = canvas;
        this.imageCanvas = imageCanvas;
        this.store = store;

        this.mode = 'idle'; // idle, drawing, moving, resizing, panning
        this.startX = 0;
        this.startY = 0;
        this.currentX = 0;
        this.currentY = 0;

        this.dragStartBox = null;
        this.resizeHandle = null;
        this.isPanning = false;
        this.spacePressed = false;

        this.setupEventListeners();
    }

    /**
     * Setup mouse and keyboard event listeners
     */
    setupEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
    }

    /**
     * Handle mouse down
     */
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;

        // Pan mode with space key
        if (this.spacePressed || e.button === 1) { // Middle mouse button
            this.mode = 'panning';
            this.startX = screenX;
            this.startY = screenY;
            this.canvas.classList.add('panning');
            e.preventDefault();
            return;
        }

        const imageCoords = this.imageCanvas.screenToImage(screenX, screenY);

        // Check if clicking on a handle
        const handle = this.getHandleAt(screenX, screenY);
        if (handle) {
            this.mode = 'resizing';
            this.resizeHandle = handle;
            this.startX = imageCoords.x;
            this.startY = imageCoords.y;
            this.dragStartBox = { ...this.store.getSelectedBox() };
            return;
        }

        // Check if clicking on a box
        const clickedBox = this.getBoxAt(imageCoords.x, imageCoords.y);
        if (clickedBox) {
            this.store.setSelectedBox(clickedBox.id);
            this.mode = 'moving';
            this.startX = imageCoords.x;
            this.startY = imageCoords.y;
            this.dragStartBox = { ...clickedBox };
            this.imageCanvas.render();
            return;
        }

        // Deselect and start drawing new box
        this.store.setSelectedBox(null);
        this.mode = 'drawing';
        this.startX = imageCoords.x;
        this.startY = imageCoords.y;
        this.currentX = imageCoords.x;
        this.currentY = imageCoords.y;
    }

    /**
     * Handle mouse move
     */
    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const imageCoords = this.imageCanvas.screenToImage(screenX, screenY);

        // Update cursor position (for status bar)
        this.updateCursorPosition(imageCoords.x, imageCoords.y);

        if (this.mode === 'panning') {
            const dx = screenX - this.startX;
            const dy = screenY - this.startY;
            this.imageCanvas.pan(dx, dy);
            this.startX = screenX;
            this.startY = screenY;
            return;
        }

        if (this.mode === 'drawing') {
            this.currentX = imageCoords.x;
            this.currentY = imageCoords.y;
            this.imageCanvas.drawPreviewBox(this.startX, this.startY, this.currentX, this.currentY);
            return;
        }

        if (this.mode === 'moving') {
            const dx = imageCoords.x - this.startX;
            const dy = imageCoords.y - this.startY;

            const newX = this.dragStartBox.x + dx;
            const newY = this.dragStartBox.y + dy;

            // Constrain to image bounds
            const currentImage = this.store.getCurrentImage();
            const constrainedX = Math.max(0, Math.min(newX, currentImage.width - this.dragStartBox.width));
            const constrainedY = Math.max(0, Math.min(newY, currentImage.height - this.dragStartBox.height));

            this.store.updateBox(this.store.getState().selectedBoxId, {
                x: constrainedX,
                y: constrainedY
            });

            this.imageCanvas.render();
            return;
        }

        if (this.mode === 'resizing') {
            this.handleResize(imageCoords.x, imageCoords.y);
            return;
        }

        // Update cursor based on hover
        this.updateCursor(screenX, screenY, imageCoords.x, imageCoords.y);
    }

    /**
     * Handle mouse up
     */
    handleMouseUp(e) {
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const imageCoords = this.imageCanvas.screenToImage(screenX, screenY);

        if (this.mode === 'panning') {
            this.canvas.classList.remove('panning');
            this.mode = 'idle';
            return;
        }

        if (this.mode === 'drawing') {
            this.finishDrawing(imageCoords.x, imageCoords.y);
            this.mode = 'idle';
            return;
        }

        if (this.mode === 'moving' || this.mode === 'resizing') {
            this.mode = 'idle';
            this.dragStartBox = null;
            this.resizeHandle = null;
            return;
        }
    }

    /**
     * Handle mouse wheel (zoom)
     */
    handleWheel(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        this.imageCanvas.zoomAt(e.deltaY > 0 ? -1 : 1, screenX, screenY);
    }

    /**
     * Handle key down
     */
    handleKeyDown(e) {
        if (e.code === 'Space' && !this.spacePressed) {
            this.spacePressed = true;
            if (this.mode === 'idle') {
                this.canvas.style.cursor = 'grab';
            }
        }

        if (e.key === 'Delete' || e.key === 'Backspace') {
            const selectedBoxId = this.store.getState().selectedBoxId;
            if (selectedBoxId) {
                this.store.deleteBox(selectedBoxId);
                this.imageCanvas.render();
                e.preventDefault();
            }
        }

        if (e.key === 'Escape') {
            if (this.mode === 'drawing') {
                this.mode = 'idle';
                this.imageCanvas.render();
            } else {
                this.store.setSelectedBox(null);
                this.imageCanvas.render();
            }
        }
    }

    /**
     * Handle key up
     */
    handleKeyUp(e) {
        if (e.code === 'Space') {
            this.spacePressed = false;
            if (this.mode === 'idle') {
                this.canvas.style.cursor = 'crosshair';
            }
        }
    }

    /**
     * Finish drawing a new box
     */
    finishDrawing(endX, endY) {
        const width = Math.abs(endX - this.startX);
        const height = Math.abs(endY - this.startY);

        // Minimum size threshold
        if (width < 5 || height < 5) {
            this.imageCanvas.render();
            return;
        }

        const currentImage = this.store.getCurrentImage();
        const state = this.store.getState();
        const classes = this.store.getClasses();

        const box = {
            classId: state.currentClassId,
            className: classes[state.currentClassId] || `class_${state.currentClassId}`,
            x: Math.max(0, Math.min(this.startX, endX)),
            y: Math.max(0, Math.min(this.startY, endY)),
            width: Math.min(width, currentImage.width),
            height: Math.min(height, currentImage.height),
            imageId: currentImage.id
        };

        const boxId = this.store.addBox(box);
        this.store.setSelectedBox(boxId);
        this.imageCanvas.render();
    }

    /**
     * Handle box resizing
     */
    handleResize(currentX, currentY) {
        const box = this.dragStartBox;
        const handle = this.resizeHandle;
        const currentImage = this.store.getCurrentImage();

        let newX = box.x;
        let newY = box.y;
        let newWidth = box.width;
        let newHeight = box.height;

        const dx = currentX - this.startX;
        const dy = currentY - this.startY;

        // Calculate new dimensions based on handle
        switch (handle.type) {
            case 'nw':
                newX = box.x + dx;
                newY = box.y + dy;
                newWidth = box.width - dx;
                newHeight = box.height - dy;
                break;
            case 'n':
                newY = box.y + dy;
                newHeight = box.height - dy;
                break;
            case 'ne':
                newY = box.y + dy;
                newWidth = box.width + dx;
                newHeight = box.height - dy;
                break;
            case 'e':
                newWidth = box.width + dx;
                break;
            case 'se':
                newWidth = box.width + dx;
                newHeight = box.height + dy;
                break;
            case 's':
                newHeight = box.height + dy;
                break;
            case 'sw':
                newX = box.x + dx;
                newWidth = box.width - dx;
                newHeight = box.height + dy;
                break;
            case 'w':
                newX = box.x + dx;
                newWidth = box.width - dx;
                break;
        }

        // Ensure minimum size
        if (newWidth < 5) {
            newWidth = 5;
            newX = box.x;
        }
        if (newHeight < 5) {
            newHeight = 5;
            newY = box.y;
        }

        // Constrain to image bounds
        newX = Math.max(0, Math.min(newX, currentImage.width - newWidth));
        newY = Math.max(0, Math.min(newY, currentImage.height - newHeight));
        newWidth = Math.min(newWidth, currentImage.width - newX);
        newHeight = Math.min(newHeight, currentImage.height - newY);

        this.store.updateBox(this.store.getState().selectedBoxId, {
            x: newX,
            y: newY,
            width: newWidth,
            height: newHeight
        });

        this.imageCanvas.render();
    }

    /**
     * Get box at image coordinates
     */
    getBoxAt(imageX, imageY) {
        const currentImage = this.store.getCurrentImage();
        if (!currentImage) return null;

        const boxes = this.store.getBoxesForImage(currentImage.id);

        // Check in reverse order (top box first)
        for (let i = boxes.length - 1; i >= 0; i--) {
            const box = boxes[i];
            if (imageX >= box.x && imageX <= box.x + box.width &&
                imageY >= box.y && imageY <= box.y + box.height) {
                return box;
            }
        }

        return null;
    }

    /**
     * Get handle at screen coordinates
     */
    getHandleAt(screenX, screenY) {
        const selectedBox = this.store.getSelectedBox();
        if (!selectedBox) return null;

        const topLeft = this.imageCanvas.imageToScreen(selectedBox.x, selectedBox.y);
        const bottomRight = this.imageCanvas.imageToScreen(
            selectedBox.x + selectedBox.width,
            selectedBox.y + selectedBox.height
        );

        const screenWidth = bottomRight.x - topLeft.x;
        const screenHeight = bottomRight.y - topLeft.y;

        const handles = this.imageCanvas.getHandlePositions(topLeft.x, topLeft.y, screenWidth, screenHeight);
        const handleSize = 8;

        for (const handle of handles) {
            const dx = screenX - handle.x;
            const dy = screenY - handle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= handleSize) {
                return handle;
            }
        }

        return null;
    }

    /**
     * Update cursor based on hover
     */
    updateCursor(screenX, screenY, imageX, imageY) {
        if (this.spacePressed) {
            this.canvas.style.cursor = 'grab';
            return;
        }

        const handle = this.getHandleAt(screenX, screenY);
        if (handle) {
            const cursors = {
                'nw': 'nw-resize',
                'n': 'n-resize',
                'ne': 'ne-resize',
                'e': 'e-resize',
                'se': 'se-resize',
                's': 's-resize',
                'sw': 'sw-resize',
                'w': 'w-resize'
            };
            this.canvas.style.cursor = cursors[handle.type];
            return;
        }

        const box = this.getBoxAt(imageX, imageY);
        if (box) {
            this.canvas.style.cursor = 'move';
            return;
        }

        this.canvas.style.cursor = 'crosshair';
    }

    /**
     * Update cursor position display
     */
    updateCursorPosition(imageX, imageY) {
        const currentImage = this.store.getCurrentImage();
        if (!currentImage) return;

        // Clamp to image bounds for display
        const x = Math.max(0, Math.min(Math.round(imageX), currentImage.width));
        const y = Math.max(0, Math.min(Math.round(imageY), currentImage.height));

        const event = new CustomEvent('cursorPosition', {
            detail: { x, y }
        });
        document.dispatchEvent(event);
    }
}

/**
 * UIController.js
 * Manages UI updates and user interactions
 */

class UIController {
    constructor(store, imageCanvas) {
        this.store = store;
        this.imageCanvas = imageCanvas;

        this.elements = {
            // Format
            loadYoloBtn: document.getElementById('loadYoloBtn'),
            loadCocoBtn: document.getElementById('loadCocoBtn'),
            folderPath: document.getElementById('folderPath'),

            // Class management
            classSelector: document.getElementById('classSelector'),
            addClassBtn: document.getElementById('addClassBtn'),
            classList: document.getElementById('classList'),
            addClassModal: document.getElementById('addClassModal'),
            newClassName: document.getElementById('newClassName'),
            addClassConfirm: document.getElementById('addClassConfirm'),
            addClassCancel: document.getElementById('addClassCancel'),

            // File list
            fileSearch: document.getElementById('fileSearch'),
            fileList: document.getElementById('fileList'),

            // Toolbar
            fileInfo: document.getElementById('fileInfo'),
            annotationCount: document.getElementById('annotationCount'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomLevel: document.getElementById('zoomLevel'),
            fitToScreenBtn: document.getElementById('fitToScreenBtn'),
            toggleBoxesBtn: document.getElementById('toggleBoxesBtn'),
            saveBtn: document.getElementById('saveBtn'),

            // Status bar
            cursorPos: document.getElementById('cursorPos'),
            statusMessage: document.getElementById('statusMessage'),
            shortcutHint: document.getElementById('shortcutHint'),

            // Modals
            shortcutsModal: document.getElementById('shortcutsModal'),
            shortcutsClose: document.getElementById('shortcutsClose'),

            // Toast
            toastContainer: document.getElementById('toastContainer'),

            // Canvas container
            canvasContainer: document.getElementById('canvasContainer')
        };

        this.setupEventListeners();
        this.setupStoreListeners();
    }

    /**
     * Setup DOM event listeners
     */
    setupEventListeners() {
        // Class selector
        this.elements.classSelector.addEventListener('change', (e) => {
            this.store.setCurrentClass(parseInt(e.target.value));
        });

        // Add class button
        this.elements.addClassBtn.addEventListener('click', () => {
            this.showAddClassModal();
        });

        this.elements.addClassConfirm.addEventListener('click', () => {
            this.handleAddClass();
        });

        this.elements.addClassCancel.addEventListener('click', () => {
            this.hideAddClassModal();
        });

        this.elements.newClassName.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleAddClass();
            }
        });

        // File search
        this.elements.fileSearch.addEventListener('input', (e) => {
            this.filterFileList(e.target.value);
        });

        // Zoom controls
        this.elements.zoomInBtn.addEventListener('click', () => {
            const currentZoom = this.store.getState().zoom;
            this.imageCanvas.setZoom(currentZoom * 1.2);
        });

        this.elements.zoomOutBtn.addEventListener('click', () => {
            const currentZoom = this.store.getState().zoom;
            this.imageCanvas.setZoom(currentZoom / 1.2);
        });

        this.elements.fitToScreenBtn.addEventListener('click', () => {
            this.imageCanvas.fitToScreen();
        });

        // Toggle boxes
        this.elements.toggleBoxesBtn.addEventListener('click', () => {
            this.store.toggleBoxVisibility();
            this.imageCanvas.render();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            this.handleGlobalKeyboard(e);
        });

        // Shortcuts modal
        this.elements.shortcutsClose.addEventListener('click', () => {
            this.hideShortcutsModal();
        });

        // Cursor position
        document.addEventListener('cursorPosition', (e) => {
            this.updateCursorPosition(e.detail.x, e.detail.y);
        });

        // Close modals on background click
        this.elements.addClassModal.addEventListener('click', (e) => {
            if (e.target === this.elements.addClassModal) {
                this.hideAddClassModal();
            }
        });

        this.elements.shortcutsModal.addEventListener('click', (e) => {
            if (e.target === this.elements.shortcutsModal) {
                this.hideShortcutsModal();
            }
        });
    }

    /**
     * Setup store event listeners
     */
    setupStoreListeners() {
        this.store.on('classes', () => this.updateClassUI());
        this.store.on('images', () => this.updateFileList());
        this.store.on('currentImage', () => this.updateCurrentImageUI());
        this.store.on('boxes', () => this.updateAnnotationCount());
        this.store.on('modified', () => this.updateSaveButton());
        this.store.on('zoom', (zoom) => this.updateZoomDisplay(zoom));
    }

    /**
     * Update class selector and list
     */
    updateClassUI() {
        const classes = this.store.getClasses();
        const currentClassId = this.store.getState().currentClassId;

        // Update selector dropdown
        this.elements.classSelector.innerHTML = '';
        classes.forEach((className, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = className;
            if (index === currentClassId) {
                option.selected = true;
            }
            this.elements.classSelector.appendChild(option);
        });

        // Update class list
        this.elements.classList.innerHTML = '';
        classes.forEach((className, index) => {
            const item = document.createElement('div');
            item.className = 'class-item';
            if (index === currentClassId) {
                item.classList.add('active');
            }

            const color = document.createElement('div');
            color.className = 'class-color';
            color.style.backgroundColor = this.imageCanvas.getClassColor(index);

            const name = document.createElement('div');
            name.className = 'class-name';
            name.textContent = className;

            item.appendChild(color);
            item.appendChild(name);

            item.addEventListener('click', () => {
                this.store.setCurrentClass(index);
                this.elements.classSelector.value = index;
                this.updateClassUI();
            });

            this.elements.classList.appendChild(item);
        });
    }

    /**
     * Update file list
     */
    updateFileList() {
        const images = this.store.getAllImages();
        const currentImageId = this.store.getState().currentImageId;

        if (images.length === 0) {
            this.elements.fileList.innerHTML = `
                <div class="empty-state">
                    <p>No images found</p>
                    <p class="hint">Check folder structure</p>
                </div>
            `;
            return;
        }

        // Sort images by filename
        images.sort((a, b) => a.fileName.localeCompare(b.fileName));

        this.elements.fileList.innerHTML = '';

        // Create flat list of images
        images.forEach(img => {
            const item = this.createFileItem(img, currentImageId);
            this.elements.fileList.appendChild(item);
        });
    }

    /**
     * Create file list item
     */
    createFileItem(image, currentImageId) {
        const item = document.createElement('div');
        item.className = 'file-item';
        if (image.id === currentImageId) {
            item.classList.add('active');
        }

        // Thumbnail (placeholder - will be replaced with actual thumbnail)
        const thumbnail = document.createElement('div');
        thumbnail.className = 'file-thumbnail';
        thumbnail.style.background = '#ddd';
        item.appendChild(thumbnail);

        // File info
        const info = document.createElement('div');
        info.className = 'file-info';

        const name = document.createElement('div');
        name.className = 'file-name';
        name.textContent = image.fileName;
        name.title = image.fileName;

        const meta = document.createElement('div');
        meta.className = 'file-meta';

        const status = document.createElement('div');
        status.className = 'file-status';
        if (image.boxes.length > 0) {
            status.classList.add('annotated');
        } else {
            status.classList.add('unannotated');
        }

        const count = document.createElement('span');
        count.textContent = `${image.boxes.length} boxes`;

        meta.appendChild(status);
        meta.appendChild(count);

        info.appendChild(name);
        info.appendChild(meta);

        item.appendChild(info);

        item.addEventListener('click', () => {
            const event = new CustomEvent('imageSelected', { detail: { imageId: image.id } });
            document.dispatchEvent(event);
        });

        return item;
    }

    /**
     * Filter file list by search term
     */
    filterFileList(searchTerm) {
        const items = this.elements.fileList.querySelectorAll('.file-item');
        const term = searchTerm.toLowerCase();

        items.forEach(item => {
            const name = item.querySelector('.file-name').textContent.toLowerCase();
            if (name.includes(term)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }

    /**
     * Update current image UI
     */
    updateCurrentImageUI() {
        const image = this.store.getCurrentImage();

        if (image) {
            this.elements.fileInfo.textContent = `${image.fileName} (${image.width} √ó ${image.height})`;
            this.elements.canvasContainer.querySelector('.empty-canvas-state').style.display = 'none';
            this.updateFileList();
        } else {
            this.elements.fileInfo.textContent = 'No image loaded';
        }

        this.updateAnnotationCount();
    }

    /**
     * Update annotation count
     */
    updateAnnotationCount() {
        const image = this.store.getCurrentImage();
        if (image) {
            const count = image.boxes.length;
            this.elements.annotationCount.textContent = `${count} box${count !== 1 ? 'es' : ''}`;
        } else {
            this.elements.annotationCount.textContent = '';
        }
    }

    /**
     * Update save button state
     */
    updateSaveButton() {
        const isModified = this.store.isCurrentImageModified();
        if (isModified) {
            this.elements.saveBtn.classList.add('unsaved');
            this.elements.saveBtn.disabled = false;
        } else {
            this.elements.saveBtn.classList.remove('unsaved');
            this.elements.saveBtn.disabled = true;
        }
    }

    /**
     * Update zoom display
     */
    updateZoomDisplay(zoom) {
        this.elements.zoomLevel.textContent = `${Math.round(zoom * 100)}%`;
    }

    /**
     * Update cursor position display
     */
    updateCursorPosition(x, y) {
        this.elements.cursorPos.textContent = `${x}, ${y}`;
    }

    /**
     * Show add class modal
     */
    showAddClassModal() {
        this.elements.addClassModal.classList.add('active');
        this.elements.newClassName.value = '';
        this.elements.newClassName.focus();
    }

    /**
     * Hide add class modal
     */
    hideAddClassModal() {
        this.elements.addClassModal.classList.remove('active');
    }

    /**
     * Handle adding a new class
     */
    handleAddClass() {
        const className = this.elements.newClassName.value.trim();
        if (className) {
            this.store.addClass(className);
            this.hideAddClassModal();
            this.showToast('success', `Class "${className}" added`);
        }
    }

    /**
     * Show shortcuts modal
     */
    showShortcutsModal() {
        this.elements.shortcutsModal.classList.add('active');
    }

    /**
     * Hide shortcuts modal
     */
    hideShortcutsModal() {
        this.elements.shortcutsModal.classList.remove('active');
    }

    /**
     * Handle global keyboard shortcuts
     */
    handleGlobalKeyboard(e) {
        // Ignore if typing in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        if (e.key === '?') {
            this.showShortcutsModal();
            e.preventDefault();
        }

        if (e.key === 'h' || e.key === 'H') {
            this.store.toggleBoxVisibility();
            this.imageCanvas.render();
            e.preventDefault();
        }

        if (e.key === '0') {
            this.imageCanvas.fitToScreen();
            e.preventDefault();
        }

        if (e.key === '+' || e.key === '=') {
            const currentZoom = this.store.getState().zoom;
            this.imageCanvas.setZoom(currentZoom * 1.2);
            e.preventDefault();
        }

        if (e.key === '-' || e.key === '_') {
            const currentZoom = this.store.getState().zoom;
            this.imageCanvas.setZoom(currentZoom / 1.2);
            e.preventDefault();
        }

        if (e.key === 'ArrowLeft') {
            this.navigateImage(-1);
            e.preventDefault();
        }

        if (e.key === 'ArrowRight') {
            this.navigateImage(1);
            e.preventDefault();
        }

        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            const event = new CustomEvent('saveRequested');
            document.dispatchEvent(event);
            e.preventDefault();
        }
    }

    /**
     * Navigate between images
     */
    navigateImage(direction) {
        const images = this.store.getAllImages();
        const currentImageId = this.store.getState().currentImageId;
        const currentIndex = images.findIndex(img => img.id === currentImageId);

        if (currentIndex === -1) return;

        const newIndex = currentIndex + direction;
        if (newIndex >= 0 && newIndex < images.length) {
            const event = new CustomEvent('imageSelected', {
                detail: { imageId: images[newIndex].id }
            });
            document.dispatchEvent(event);
        }
    }

    /**
     * Show toast notification
     */
    showToast(type, message, duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;

        const icons = {
            success: '‚úì',
            error: '‚úó',
            warning: '‚ö†',
            info: '‚Ñπ'
        };

        toast.innerHTML = `
            <span class="toast-icon">${icons[type] || icons.info}</span>
            <span class="toast-message">${message}</span>
        `;

        this.elements.toastContainer.appendChild(toast);

        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => {
                this.elements.toastContainer.removeChild(toast);
            }, 300);
        }, duration);
    }

    /**
     * Update status message
     */
    setStatus(message) {
        this.elements.statusMessage.textContent = message;
    }

    /**
     * Set folder path display
     */
    setFolderPath(path) {
        this.elements.folderPath.textContent = path;
    }
}

/**
 * main.js
 * Application initialization and orchestration
 */








class NotatoApp {
    constructor() {
        // Initialize modules
        this.store = new AnnotationStore();
        this.fileManager = new FileManager();

        // Format handlers registry
        this.formatHandlers = new Map([
            ['yolo', new YOLOHandler()],
            ['coco', new COCOHandler()]
        ]);
        this.currentHandler = this.formatHandlers.get('yolo'); // Default to YOLO

        // Get canvas
        const canvas = document.getElementById('mainCanvas');
        this.imageCanvas = new ImageCanvas(canvas, this.store);
        this.boxEditor = new BoxEditor(canvas, this.imageCanvas, this.store);
        this.uiController = new UIController(this.store, this.imageCanvas);

        this.currentImageCache = new Map(); // imageId -> image data URL

        this.setupEventListeners();
        this.initialize();
    }

    /**
     * Initialize application
     */
    initialize() {
        // Set default class
        this.store.setClasses(['object']);
        this.uiController.setStatus('Ready');
    }

    /**
     * Setup event listeners
     */
    setupEventListeners() {
        // Load YOLO button
        document.getElementById('loadYoloBtn').addEventListener('click', () => {
            this.currentHandler = this.formatHandlers.get('yolo');
            this.store.setFormat('yolo');
            this.handleOpenFolder();
        });

        // Load COCO button
        document.getElementById('loadCocoBtn').addEventListener('click', () => {
            this.currentHandler = this.formatHandlers.get('coco');
            this.store.setFormat('coco');
            this.handleOpenFolder();
        });

        // Save button
        document.getElementById('saveBtn').addEventListener('click', () => {
            this.handleSave();
        });

        // Image selection
        document.addEventListener('imageSelected', (e) => {
            this.loadImage(e.detail.imageId);
        });

        // Save request
        document.addEventListener('saveRequested', () => {
            this.handleSave();
        });
    }

    /**
     * Handle opening a folder
     */
    async handleOpenFolder() {
        try {
            // Clear all prior state IMMEDIATELY when user attempts to load a folder
            // This happens regardless of whether the load succeeds or fails
            this.store.clear();
            this.currentImageCache.clear();
            this.imageCanvas.clear();
            this.formatHandlers.get('coco').initEmpty();
            this.formatHandlers.get('yolo').setClasses([]);
            this.fileManager.clear();  // Clear file cache to prevent reading stale files

            this.uiController.setStatus('Opening folder...');

            // Check API support
            if (!this.fileManager.isFileSystemAccessSupported()) {
                this.uiController.showToast('error', 'File System Access API not supported in this browser');
                return;
            }

            // Open folder
            const files = await this.fileManager.openFolder();

            if (files.length === 0) {
                throw new Error('No images found in selected folder');
            }

            this.uiController.setStatus(`Loading ${files.length} images...`);
            this.uiController.setFolderPath(this.fileManager.getDirectoryName());

            // Load images into store
            for (const file of files) {
                const imageData = await this.fileManager.loadImage(file.file);

                const imageId = this.store.addImage({
                    fileName: file.name,
                    filePath: file.path,
                    width: imageData.width,
                    height: imageData.height
                });

                this.currentImageCache.set(imageId, imageData.url);
            }

            // Load annotations using current handler
            const images = this.store.getAllImages();
            const { boxes, classes } = await this.currentHandler.load(
                this.fileManager,
                images
            );

            // Populate store with loaded annotations
            this.store.setClasses(classes);
            for (const [imageId, imageBoxes] of boxes.entries()) {
                imageBoxes.forEach(box => {
                    this.store.addBox({
                        ...box,
                        imageId
                    });
                });
            }

            // Load first image
            if (images.length > 0) {
                this.loadImage(images[0].id);
            }

            this.uiController.showToast('success', `Loaded ${files.length} images`);
            this.uiController.setStatus('Ready');

        } catch (error) {
            console.error('Error opening folder:', error);
            this.uiController.showToast('error', error.message);
            this.uiController.setStatus('Error');
        }
    }


    /**
     * Load and display an image
     */
    async loadImage(imageId) {
        try {
            const image = this.store.getImage(imageId);
            if (!image) return;

            this.uiController.setStatus('Loading image...');

            // Set current image BEFORE loading so render() uses correct boxes
            this.store.setCurrentImage(imageId);

            const imageUrl = this.currentImageCache.get(imageId);
            await this.imageCanvas.loadImage(imageUrl, image.width, image.height);

            this.uiController.setStatus('Ready');

        } catch (error) {
            console.error('Error loading image:', error);
            this.uiController.showToast('error', 'Failed to load image');
        }
    }

    /**
     * Save current image annotations
     */
    async handleSave() {
        try {
            const currentImage = this.store.getCurrentImage();
            if (!currentImage) {
                this.uiController.showToast('warning', 'No image loaded');
                return;
            }

            // Don't save if there are no changes
            if (!this.store.isCurrentImageModified()) {
                return;
            }

            this.uiController.setStatus('Saving...');

            const boxes = this.store.getBoxesForImage(currentImage.id);
            const classes = this.store.getClasses();

            await this.currentHandler.save(
                this.fileManager,
                currentImage,
                boxes,
                classes
            );

            this.store.clearImageModified();
            this.uiController.showToast('success', 'Saved successfully');
            this.uiController.setStatus('Ready');

        } catch (error) {
            console.error('Error saving:', error);
            this.uiController.showToast('error', 'Failed to save: ' + error.message);
            this.uiController.setStatus('Error');
        }
    }

}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.notatoApp = new NotatoApp();
});
</script>
</body>
</html>
